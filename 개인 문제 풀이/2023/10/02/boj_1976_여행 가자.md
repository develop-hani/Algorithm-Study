# BOJ 1976λ² μ—¬ν–‰κ°€μ

[BOJ 1976λ² μ—¬ν–‰ κ°€μ](https://www.acmicpc.net/problem/1976)

### π¤” λ¬Έμ  μ΄ν•΄ν•κΈ°

1. Nκ°μ λ„μ‹ μ¤‘ μ „μ²΄ λλ” μΌλ¶€μ λ„μ‹λ§ μ—°κ²°λμ–΄ μλ‹¤.
2. Mκ°μ λ„μ‹λ¥Ό μ°¨λ΅€λ€λ΅ λ°©λ¬Έν•  μ μλ”μ§€ κµ¬ν•λ‹¤.

### β­ μ•κ³ λ¦¬μ¦

1. Union find

- λ°©λ¬Έν•λ ¤λ” λ„μ‹λ“¤μ΄ λ¨λ‘ μ—°κ²°λμ–΄ μλ‹¤λ©΄ Yes, μ•„λ‹λ©΄ No

### π’» λ¬Έμ λ¥Ό ν•΄κ²°ν• μ½”λ“

```java
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class Main {

    static int N, M; // N: λ„μ‹μ κ°μ, M: λ°©λ¬Έν•  λ„μ‹μ κ°μ
    static int[] parent; // λ¶€λ¨ λ…Έλ“λ¥Ό μ €μ¥ν•  λ°°μ—΄
    static List<Integer> city = new ArrayList<>(); // λ°©λ¬Έν•  λ„μ‹λ“¤(μ¤‘λ³µ μ κ±°)

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();

        // μ…λ ¥ λ° μ΄κΈ°ν™”
        N = Integer.parseInt(br.readLine());
        M = Integer.parseInt(br.readLine());

        parent = new int[N];
        for (int i = 0; i < N; ++i) {
            parent[i] = i;
        }

        StringTokenizer st;
        for (int i = 0; i < N; ++i) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < i; ++j) st.nextToken(); // λ„μ–΄κ°€κΈ°
            for (int j = i; j < N; ++j) {
                if (Integer.parseInt(st.nextToken()) == 1) { // μ—°κ²°λμ–΄ μλ‹¤λ©΄ parentμ— ν‘μ‹ν•κΈ°
                    union(i, j);
                }
            }
        }

        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < M; ++i) {
            city.add(Integer.parseInt(st.nextToken()) - 1); // λ„μ‹ λ²νΈλ¥Ό 0 ~ N-1λ΅ λ³€κ²½
        }
        city.stream().distinct().collect(Collectors.toList());

        // λ΅μ§ λ° μ¶λ ¥
        sb.append(travel() ? "YES" : "NO").append("\n");

        bw.write(sb.toString());
        bw.flush();
        bw.close();
        br.close();
    }

    /**
     * ν•΄λ‹Ή κµ­κ°€λ“¤μ„ λ°©λ¬Έν•  μ μλ”μ§€ νμ•…
     */
    private static boolean travel() {
        int start = find(city.get(0));
        for (int i = 1; i < city.size(); ++i) {
            int now = find(city.get(i));
            if (!(start == now)) return false;
        }
        return true;
    }

    private static void union(int x, int y) {
        int xParent = find(x);
        int yParent = find(y);

        if (xParent != yParent) {
            parent[Math.min(xParent, yParent)] = Math.max(xParent, yParent);
        }
    }

    private static int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

}
```
