# BOJ 17136ë²ˆ ìƒ‰ì¢…ì´ ë¶™ì´ê¸°

[17136ë²ˆ ìƒ‰ì¢…ì´ ë¶™ì´ê¸°](https://www.acmicpc.net/problem/17136)

### ğŸ¤” ë¬¸ì œ ì´í•´í•˜ê¸°

1. 10 x 10 í¬ê¸°ì˜ ì¢…ì´ì˜ 1ì´ ì íŒ ì¹¸ì—ëŠ” ìƒ‰ì¢…ì´ë¥¼ ë¶™ì´ê³ , 0ì´ ì íŒ ì¹¸ì—ëŠ” ìƒ‰ì¢…ì´ë¥¼ ë¶™ì¼ ìˆ˜ ì—†ë‹¤.
2. ìƒ‰ì¢…ì´ëŠ” í•œ ë³€ì˜ ê¸¸ì´ê°€ 1, 2, 3, 4, 5ì¸ ì •ì‚¬ê°í˜•
   ê° ìƒ‰ì¢…ì´ ìµœëŒ€ ê°œìˆ˜ == 5
3. ì‚¬ìš©í•˜ëŠ” ìƒ‰ì¢…ì´ì˜ ìµœì†Œ ê°œìˆ˜ êµ¬í•˜ê¸°

### â­ ì•Œê³ ë¦¬ì¦˜

- DFS
- Back tracking

### ğŸ“– ìŠ¤í† ë¦¬ ë¼ì¸

1. ìƒ‰ì¢…ì´ë¥¼ ë¶™ì—¬ì•¼ í•˜ëŠ” ì¹¸ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ìœ ì§€
2. í•´ë‹¹ ì¹¸ì— í¬ê¸°ê°€ í° ìƒ‰ì¢…ì´ë¶€í„° ë¶™ì´ê¸°
   í° ìƒ‰ì¢…ì´ë¥¼ ë¶™ì¼ ìˆ˜ ìˆì„ ë•Œ, ìƒ‰ì¢…ì´ì˜ ê°œìˆ˜ê°€ ìµœì†Œê°€ ë˜ë¯€ë¡œ í° ìƒ‰ì¢…ì´ë¶€í„° ë¶™ì¸ë‹¤.
   - ë¶™ì¼ ìˆ˜ ìˆë‹¤ë©´,
     ìƒ‰ì¢…ì´ë¥¼ ë¶™ì´ê³ , ìƒ‰ì¢…ì´ê°€ ë¶™ì€ ì¹¸ë“¤ì€ ë°©ë¬¸ ì²˜ë¦¬í•œë‹¤.
   - ë¶™ì¼ ìˆ˜ ì—†ë‹¤ë©´,
     ë” ì‘ì€ í¬ê¸°ì˜ ìƒ‰ì¢…ì´ë¥¼ ë¶™ì—¬ë³¸ë‹¤.
3. ì²˜ë¦¬ ì¡°ê±´
   - ë‹¤ë¥¸ ì¹¸ì—ì„œ í¬ê¸°ê°€ 2ì´ìƒì¸ ìƒ‰ì¢…ì´ë¥¼ ë¶™ì—¬ í˜„ì¬ ì¹¸ì— ì´ë¯¸ ìƒ‰ì¢…ì´ê°€ ìˆì„ ë•Œ
   - ê¹ ìƒ‰ì¢…ì´ê°€ ì´ë¯¸ ìµœì†Œ ìƒ‰ì¢…ì´ ìˆ˜ë³´ë‹¤ í´ ë•Œ

### ğŸ’» ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œ

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

public class Main_17136_ìƒ‰ì¢…ì´ë¶™ì´ê¸° {

	static int[][] debug = new int[10][10];

	static int[] amount = { 0, 5, 5, 5, 5, 5 };// ê° ì •ì‚¬ê°í˜• í¬ê¸°ì˜ ìƒ‰ì¢…ì´ ìˆ˜
	static List<Point> list = new ArrayList<>(); // ì¢…ì´ë¥¼ ì˜¬ë ¤ë†”ì•¼ í•  ê³³
	static Map<Point, Boolean> visited = new HashMap<>();
	static int min = 26;

	private static class Point {
		int x, y;

		public Point(int x, int y) {
			super();
			this.x = x;
			this.y = y;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + x;
			result = prime * result + y;
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Point other = (Point) obj;
			if (x != other.x)
				return false;
			if (y != other.y)
				return false;
			return true;
		}
	}

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		StringTokenizer st = null;

		// ì…ë ¥
		for (int i = 0; i < 10; ++i) {
			st = new StringTokenizer(br.readLine(), " ");
			for (int j = 0; j < 10; ++j) {
				int tmp = Integer.parseInt(st.nextToken());
				if (tmp == 1) {
					list.add(new Point(i, j));
					visited.put(new Point(i, j), false);
					debug[i][j] = 1;
				}
			}
		}

		// êµ¬í˜„
		solve(0, 0);

		// ì¶œë ¥
		sb.append(min < 26 ? min : -1).append("\n");

		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}

	// idx: í˜„ì¬ ìƒ‰ì¢…ì´ë¥¼ ê¹”ê³  ìˆëŠ” ìœ„ì¹˜, cnt: í˜„ì¬ê¹Œì§€ ê¹ ìƒ‰ì¢…ì´ì˜ ìˆ˜
	private static void solve(int idx, int cnt) {
		if (idx < list.size() && visited.get(list.get(idx))) solve(idx + 1, cnt); // ì´ë¯¸ í•´ë‹¹ ì¹¸ì— ìƒ‰ì¢…ì´ê°€ ê¹”ë ¤ìˆìŒ
		if (cnt > min) return; // ì´ë¯¸ ê¹”ì•„ë‘” ìƒ‰ì¢…ì´ì˜ ìˆ˜ê°€  minë³´ë‹¤ í¬ë‹¤ë©´ ë” ë³¼ í•„ìš” ì—†ìŒ

		if (idx == list.size()) {
			if (cnt < min) min = cnt;
			return;
		}

		for (int k = 5; k > 0; --k) { // í¬ê¸° ë³„ë¡œ ìƒ‰ì¢…ì´ ê¹”ì•„ë³´ê¸°
			// kì‚¬ì´ì¦ˆì˜ ìƒ‰ì¢…ì´ê°€ ë‚¨ì•„ìˆëŠ”ì§€ í™•ì¸
			if (!left(k)) continue;

			// í•´ë‹¹ ì¹¸ì— ìƒ‰ì¢…ì´ë¥¼ ê¹” ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
			if (can(list.get(idx).x, list.get(idx).y, k)) {
				color(true, list.get(idx).x, list.get(idx).y, k);// ìƒ‰ì¢…ì´ë¥¼ ê¹”ì
				solve(idx + 1, cnt + 1);
				color(false, list.get(idx).x, list.get(idx).y, k);// ìƒ‰ì¢…ì´ë¥¼ ì—†ì• ì
			}

		}
	}

	// í•´ë‹¹ í¬ê¸°ì˜ ìƒ‰ì¢…ì´ê°€ ë‚¨ì•„ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
	private static boolean left(int k) {
		if (amount[k] - 1 < 0) return false;
		return true;
	}

	// í•´ë‹¹ ì¹¸ì— ì£¼ì–´ì§„ í¬ê¸°ì˜ ìƒ‰ì¢…ì´ë¥¼ ê¹” ìˆ˜ ìˆëŠ”ì§€ ì‚´í´ë³´ëŠ” í•¨ìˆ˜
	private static boolean can(int x, int y, int k) {
		for (int i = 0; i < k; ++i) {
			for (int j = 0; j < k; ++j) {
				Point p = new Point(x + i, y + j);
				if (!list.contains(p) || visited.get(p)) return false;
			}
		}
		return true;
	}

	// í•´ë‹¹ ì¹¸ì— ìƒ‰ì¢…ì´ë¥¼ ê¹”ê±°ë‚˜ ì—†ì• ëŠ” í•¨ìˆ˜
	// type: true-ìƒ‰ì¢…ì´ë¥¼ ê¹ë‹¤, false-ìƒ‰ì¢…ì´ë¥¼ ì—†ì•¤ë‹¤.
	private static void color(boolean type, int x, int y, int k) {
		for (int i = 0; i < k; ++i) {
			for (int j = 0; j < k; ++j) {
				visited.put(new Point(x + i, y + j), type);
				if(type) debug[x+i][y +j] += 1;
				else debug[x+i][y +j] -= 1;
			}
		}

		if (type) --amount[k];
		else ++amount[k];
	}
}

```
